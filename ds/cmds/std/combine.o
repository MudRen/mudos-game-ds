// say.c

#include <ansi.h>

inherit F_CLEAN_UP;

int main(object me, string arg)
{
  string who,flag;
  object target,*members;
  int i;

  write("\n...目前協力技暫時不開放...\n\n");
  return 1;

  if(!arg)
  {
   members=me->query_members();
   if(sizeof(members)<1) return notify_fail("你目前沒有合作的對象。\n");
   write("目前和你合作的人有:\n\n");
   for(i=0;i<sizeof(members);i++)
   {
    write("  "+members[i]->short()+"\n");
   }
   write("\n");
   return 1;
  }

  if( sscanf(arg, "%s %s", who, flag)==2 )
  {
   if(flag != "off") return notify_fail("指令格式錯誤。(請用help combine查詢)\n");
   target = present(who,environment(me));
   if(!target) target=find_living(who);
   if(!target) return notify_fail("這裡沒有這個人。\n");
   if(!living(target)) return notify_fail("對方不是活著的人。\n");
   if(me->remove_members(target))
   {
    target->remove_members(me);
    tell_object(target,me->name()+"決定不再和你合作了。\n");
    tell_object(me,"你決定不再和"+target->name()+"合作了。\n");
    return 1;
   }
   else return notify_fail("對方並沒有和你合作。\n");
  }
  
  target = present(arg,environment(me));
  if(!target) return notify_fail("這裡沒有這個人。\n");
  if(!living(target)) return notify_fail("只能和活著的人合作。\n");
  if(userp(me) && !userp(target)) return notify_fail("目前只能和玩家合作。\n");
  if(me->add_members(target))
  {
   target->add_members(me);
   message_vision("$N決定和$n協力作戰。\n",me,target);
   return 1;
  }
  else return notify_fail("你們目前已經有合作關係了。\n");
}

int help (object me)
{
	write(@HELP
指令格式: combine <人物> <off>

聯合作戰: 可以和其他人協力, 戰鬥時有可能使出更具威力之協力技。
	  只輸入combine時, 會顯示和你有合作關係的全部人員名單.
	  附加 off 參數則會取消合作關係.

註: 協力技的必須是在攻擊相同對手時才有可能出現.
 
HELP
	);
	return 1;
}
