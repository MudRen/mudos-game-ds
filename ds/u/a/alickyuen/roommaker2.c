#define RMK_VERSION " (v3.2 修正版) "
inherit ITEM;

string *special_props = ({
        "short", "long" });
int save_room_file(string yn, string file, string str);
int do_mkroom (string file);
int get_short (string rep, string arg);
int get_long (string rep, string arg);
int get_file_name (string rep);
int get_no_fight (string rep);
int get_no_magic (string ep);
int get_no_clean_up (string rep);
int get_valid_startroom (string rep);
int confirm_outdoors (string rep, string arg);
int get_item_desc_name (string rep);
int get_item_desc (string rep, string arg);
int get_exits (string rep);
int get_exit (string rep, string arg);
int get_objects (string rep);
int save_file();
int init_var();

mapping tmp = ([
  "no_fight"            :       0,
  "no_magic"            :       0,
  "no_clean_up"         :       0,
  "valid_startroom"     :       0,
  "file_name"           :       "",
  "short"               :       "",
  "long"                :       "",
  "outdoors"            :       "",
  "item_desc"           :       ([]),
  "exits"               :       ([]),
  "objects"             :       ([]),
]);

string *special_props = ({
        "short", "long", "file_name" });

int create()
{
        set_name("房間編輯器" + RMK_VERSION, ({ "roommaker", "maker" }) );
        set_weight(1);
        set("value",0);
        set("unit", "個" );
        set("long", @LONG
這是一個用來「快速」製造房間的工具﹐幫助時間不多或有嚴重  lag 的巫師
利用線上輸入製造簡單的房間﹐不過如果你想提高自己區域房間的品質﹐最好
不要太依賴這個東西, 當你制造房間時, 會有一堆問題, 如果你想用預設值,
請直接按 enter, 如果想放棄, 請用句點結束。

mkroom <方向> <房間檔名>        造出一個「空」房間
rset <房間屬性> <屬性內容>      設定你目前所在房間的屬性
uset <房間屬性>                 取消目前所在房間的某項屬性
connect <方向> <房間檔名>       將你目前所在的房間連接一個出口到另一個房間。
dconnect <方向>                 取消一個出口
addobj <物件檔名> <個數>        在該房間增加物件
delobj <物件檔名>               取消該房間的物件
saveroom                        將你目前所在的房間存檔。

注意: 可以用 help roommaker 取得詳細解說
LONG
        );
        setup();
}

int init()
{
        if( wizardp(environment()) ) {
                seteuid(getuid(environment()));
                add_action("do_mkroom", "mkroom");
                add_action("do_rset", "rset");
                add_action("do_uset", "uset");
                add_action("do_setlong", "setlong");
                add_action("do_connect", "connect");
                add_action("do_dconnect", "dconnect");
                add_action ("do_addobj", "addobj");
                add_action ("do_delobj", "delobj");
                add_action("do_saveroom", "saveroom");
        }
}

string ob_path(mixed ob)
{
        string file;
        string *dir;
        int     i;

        if (objectp(ob))
          file = base_name(ob);
        else if (stringp(ob)) file = ob;
        else return "/";
        dir = explode(file, "/");
        file = "/";
        for (i=0; i<sizeof(dir)-1; i++)
          file += dir[i]+"/";
        return file;
}

string get_cwd()
{
  object        env;
  string        file;
  int           i;

  env = environment(this_player());
  file = file_name(env) + ".c";
  i = strlen(file)-1;
  while( (i > 0) && (file[i]!='/')) i--;
  if (i>0) return file[0..i];
  else return "/";
}

int do_delobj (string arg)
{
        mapping objects;
        object  ob;
        string file, cwd;
        int     num;

        if( !arg || sscanf(arg, "%s", file)!=1 )
                return notify_fail("指令格式﹕delobj <物件檔名>\n"
                                   "      如: delobj /open/su/obj/cloth\n");
        objects = environment(this_player())->query("objects");
        if (ob=present (file, environment(this_player()))) {
          file = resolve_path(this_player()->query("cwd"), file);
          if( mapp(objects) )
                map_delete (objects, file);
          destruct (ob);
          write("Ok.\n");
          return 1;
        }
        else
          return notify_fail ("系統告訴你, 沒這樣東東: "+file+"\n");
}

int do_addobj (string arg)
{
  mapping objects;
  string file;
  object ob, me;
  int   num;

  if( !arg || sscanf(arg, "%s %d", file, num)!=2 )
    return notify_fail("指令格式﹕addobj <物件檔名> <物件個數>\n");
  me = this_player();
  file = resolve_path(me->query("cwd"), file);
  ob = new (file);
  if (!ob) return notify_fail ("系統告訴你: 沒那個物件: "+file+"。\n");
  ob->move(environment (me));
  objects  = environment(me)->query("objects");
log_file( "static/addobj", sprintf("%s --> %s (%s)\n",me->query("id"),
ob->query("name"), ob->query("id")));
  if( mapp(objects) )
    objects[file] = num;
  else
    environment(me)->set("objects", ([ file:num ]) );
  write("Ok.\n");

  return 1;
}

void done_setlong (object me, string text)
{
        environment(me)->set("long", text);
        return ;
}

int do_setlong ()
{
  this_player()->edit( (: done_setlong, this_player() :) );
  return 1;
}

int do_uset(string arg)
{
        string prop, str;

        if( !arg || sscanf(arg, "%s", prop)!=1 )
                return notify_fail("指令格式﹕uset <房間屬性>\n"
                                   "      如: uset light\n");

        environment(this_player())->delete(prop);
        write("Ok.\n");
        return 1;
}

int do_rset(string arg)
{
        string prop,str;
        int data, i, n;

        if( !arg || sscanf(arg, "%s %s", prop, str)!=2 )
                return notify_fail("指令格式﹕rset <房間屬性> <屬性內容>\n");

        n = strlen (str);
        if (str[0] == '"' && str[n-1] == '"') {
          write ("set "+prop+" = \""+str[1..n-2]+"\"\n");
          environment(this_player())->set(prop, str[1..n-2]);
          return 1;
        }

        data = 0;
        for (i=0; i<n; i++)
          if (str[i] < '0' || str[i] > '9') {
            data = 1;
            break;
          }

        if( !data && sscanf(str, "%d", data)==1 ) {
          write ("set "+prop+" = "+data+"\n");
          environment(this_player())->add(prop, data);
        }
        else {
          write ("set "+prop+" = \""+str+"\"\n");
          environment(this_player())->set(prop, str);
        }
        return 1;
}

int do_dconnect(string arg)
{
        mapping exits;
        string dir;

        if( !arg || sscanf(arg, "%s", dir)!=1 )
                return notify_fail("指令格式﹕dconnect <方向>\n"
                                   "      如: dconnect east\n");
        exits = environment(this_player())->query("exits");
        if( mapp(exits) )
                map_delete (exits, dir);
        write("Ok.\n");
        return 1;
}

int do_connect(string arg)
{
        object  from;
        mapping exits;
        string dir, file;

        from = environment(this_player());
        if( !arg || sscanf(arg, "%s %s", dir, file)!=2 )
                return notify_fail("指令格式﹕connect <方向> <房間檔名>\n");
        file = resolve_path(ob_path(from), file);
        exits = from->query("exits");
        if( mapp(exits) )
                exits[dir] = file;
        else
                from->set("exits", ([ dir: file ]) );
         write("Ok.\n");
        return 1;
}

int save_room_file(string yn, string file, string str)
{
  string        tmp;
  int           i;

  if( strlen(yn)<1 || yn[0]!='y' ) return 1;

  i = sizeof(file)-1;
  if (!(file[i] == 'c' && file[i-1] == '.')) file = file+".c";
  write ("file name is " + file + "\n");
  if ( write_file(file, str, 1) ) {
    write("Ok.\n");
    return 1;
  }
  else {
    write ("roommaker 嘗試寫入("+file+")失敗!!\n");
    return 0;
  }
}

void owner_is_killed() { destruct(this_object()); }

int do_mkroom(string arg)
{
  string        here, dir;
  int           status=0;

  if (!arg) return
    notify_fail ("mkroom [<方向> <房間的檔名>] 或 mkroom <房間的檔名>\n");
  init_var();
  here  = file_name (environment(this_player()));
  if (sscanf (arg, "%s %s", dir, arg) == 2) {
    arg = resolve_path(get_cwd(), arg);
    do_connect (dir+" "+arg);
  }
  else
   arg = resolve_path(this_player()->query("cwd"), arg);

  if (arg == here) {
    write ("請輸入檔名, 請勿命名為 "+here+" : ");
    input_to ( "get_file_name" );
  }
  else {
    tmp["file_name"] = arg;
    write ("file name is "+arg+"\n");
    write ("請輸入 no_fight 的值 (0 預設為可戰鬥) : ");
    input_to ( "get_no_fight" );
  }
  return 1;
}

int get_file_name (string rep)
{
  string        dir, *path;

  if (rep == ".") { write ("你放棄本次編輯。\n"); return 1; }
  else if (rep=="") {
    write ("不可以沒有檔名, 請再輸入一次, 放棄編輯請按句點 . 結束\n");
    input_to ( "get_file_name" );
    return 1;
  }
  else {
    dir = file_name (environment(this_player()));
    path = explode (dir, "/");
    path[sizeof(path)-1] = "/"+rep;
    tmp["file_name"] = "/"+implode (path, "/");
    write ("file name is "+rep+"\n");
  }

  write ("請輸入 no_fight 的值 (0 預設為可戰鬥) : ");
  input_to ( "get_no_fight" );
  return 1;
}

int get_no_fight (string rep)
{
  if (rep == ".") { write ("你放棄本次編輯。\n"); return 1; }
  else if (rep == "") tmp["no_fight"] = 0;
  else if (sscanf (rep, "%d", tmp["no_fight"]) != 1) {
    write ("你的輸入不是數字, 應該是 0 或 1\n");
    write ("請輸入 no_fight 的值 (0 預設為可戰鬥) : ");
    input_to ( "get_no_fight" );
    return 1;
  }

  write ("請輸入 no_magic 的值 (0 預設為可施魔法) : ");
  input_to ( "get_no_magic" );

  return 1;
}

int get_no_magic (string rep)
{
  if (rep == ".") { write ("你放棄本次編輯。\n"); return 1; }
  else if (rep == "") tmp["no_magic"] = 0;
  else if (sscanf (rep, "%d", tmp["no_magic"]) != 1) {
    write ("你的輸入不是數字, 應該是 0 或 1\n");
    write ("請輸入 no_magic 的值 (0 預設為可施魔法) : ");
    input_to ( "get_no_magic" );
    return 1;
  }

  write ("請輸入 no_clean_up 的值 (0 預設為要 reborn) : ");
  input_to ( "get_no_clean_up" );
  return 1;
}

int get_no_clean_up (string rep)
{
  if (rep == ".") { write ("你放棄本次編輯。\n"); return 1; }
  else if (rep == "") tmp["no_clean_up"] = 0;
  else if (sscanf (rep, "%d", tmp["no_clean_up"]) != 1) {
    write ("你的輸入不是數字, 應該是 0 或 1\n");
    write ("請輸入 no_clean_up 的值 (0 預設為可施魔法) : ");
    input_to ( "get_no_clean_up" );
    return 1;
  }

  write ("請輸入 valid_startroom 的值 (0 預設為本房間不可當起點) : ");
  input_to ( "get_valid_startroom" );
  return 1;
}

int get_valid_startroom (string rep)
{
  if (rep == ".") { write ("你放棄本次編輯。\n"); return 1; }
  else if (rep == "") tmp["valid_startroom"] = 0;
  else if (sscanf (rep, "%d", tmp["no_clean_up"]) != 1) {
    write ("你的輸入不是數字, 應該是 0 或 1\n");
    write ("請輸入 valid_startroom 的值 (0 預設為本房間不可當起點) : ");
    input_to ( "get_valid_startroom" );
    return 1;
  }

  write ("請輸入房間名稱 short (空房間) : ");
  input_to ( "get_short", "空房間" );
  return 1;
}

int get_short (string rep, string arg)
{
  string long="這是一間什麼都沒有的房間。\n";

  if (rep == ".") { write ("你放棄本次編輯。\n"); return 1; }
  else if (rep=="") tmp["short"] = arg;
  else tmp["short"] = rep;

  write ("請輸入 long 的值 (" + long + ") : \n");
  this_player()->edit( (: get_long, long :) );

  return 1;
}

int get_long (string arg, string rep)
{
  if (rep=="") tmp["long"] = arg;
 else tmp["long"] = rep;

  write ("是戶外嗎? (y) : ");
  input_to ( "confirm_outdoors", "y" );
  return 1;
}

int confirm_outdoors (string rep, string arg)
{
  string d;

  if (rep == ".") { write ("你放棄本次編輯。\n"); return 1; }
  else if (rep == "n") {
        write ("請輸入景觀 item_desc 的名稱, 如果想結束景觀, 請直接按 enter : ")
;
        input_to ( "get_item_desc_name" );
        return 1;
 }
  else if ( arg == "y" && (rep == "" || rep[0] == 'y' || rep[0] == 'Y') ) {
    d = "/"+implode( explode(this_player()->query("cwd"), "/")[0..1], "/");
    write ("戶外是屬於哪一個目錄? ("+d+") : ");
    input_to ( "confirm_outdoors", d );
    return 1;
 }
  else if (rep=="") tmp["outdoors"] = arg;
  else tmp["outdoors"] = rep;

  write ("請輸入景觀 item_desc 的名稱, 如果想結束景觀, 請直接按 enter : ");
  input_to ( "get_item_desc_name" );
  return 1;
}

int get_item_desc_name (string rep)
{
  if (rep == ".") { write ("你放棄本次編輯。\n"); return 1; }
  else if (rep=="") {
    write ("請設定出口 exits 的連結方向, 想結束設定, 請直接按 enter : ");
    input_to ( "get_exits" );
    return 1;
  }

  write ("請輸入 "+rep+" 的景觀內容, 想結束時請直接按 . 離開編輯\n");
  tmp["item_desc"][rep] = "";
  this_player()->edit ( (: get_item_desc, rep :) );
  return 1;
}

int get_item_desc (string arg, string rep)
{
  if (rep != "") {
    tmp["item_desc"][arg] = rep;
    write ("請輸入下一景觀 item_desc 的名稱, 想結束景觀, 請直接按 enter : ");
    input_to ( "get_item_desc_name" );
    return 1;
  }

  write ("請設定出口 exits 的連結方向, 想結束設定, 請直接按 enter : ");
  input_to ( "get_exits" );
  return 1;
}

int get_exits (string rep)
{
  if (rep == ".") { write ("你放棄本次編輯。\n"); return 1; }
  else if (rep=="") {
    if (tmp["exits"][""]) map_delete(tmp["exits"], "");
    write ("請設定物件 objects 的檔名, 想結束設定, 請直接按 enter :\n");
    input_to ( "get_objects" );
    return 1;
 }
  else {
    write ("請輸入 "+rep+" 的連結房間檔名, 可以採用相對路徑法 : ");
    tmp["exits"][rep] = "";
    input_to ( "get_exit", rep );
  }
  return 1;
}

int get_exit (string rep, string arg)
{
  if (rep != "") {
    tmp["exits"][arg] = resolve_path(this_player()->query("cwd"), rep);
    write ("請設定出口 exits 的方向, 想結束設定, 請直接按 enter : ");
    input_to ( "get_exits" );
    return 1;
  }

  write ("請設定物件 objects 的檔名, 想結束設定, 請直接按 enter : ");
  input_to ( "get_objects" );
  return 1;
}
int get_objects (string rep)
{
  object        ob;

  if (rep == ".") { write ("你放棄本次編輯。\n"); return 1; }
  else if (rep=="") {
    save_file ();
    return 1;
  }

  rep=resolve_path(this_player()->query("cwd"), rep);
  ob = new (rep);
  if (!ob) {
    write ("系統告訴你: 沒那個物件: "+rep+"。\n");
    write ("請設定物件 objects 的檔名, 想結束設定, 請直接按 enter : ");
    input_to ( "get_objects" );
    return 1;
  }

  destruct (ob);

  write ("請輸入 "+rep+" 的物件個數 : ");
  tmp["objects"][rep] = 1;
  input_to ( "get_object", rep );
  return 1;
}

int get_object (string rep, string arg)
{
  int           n;

  if (rep != "") {
    if (sscanf(rep, "%d", n) != 1) {
      write ("你輸的值不合法, 請重新輸入 "+arg+" 的物件個數 : ");
      input_to ( "get_object", arg );
      return 1;
    }
    else {
      tmp["objects"][arg] = n;
      write ("請設定物件 objects 的檔名, 想結束設定, 請直接按 enter : ");
      input_to ( "get_objects" );
      return 1;
    }
  }

  tmp["objects"][arg] = 1;
  save_file();
  return 1;
}

int save_file()
{
  string        room_code, *name, file;
  int           i, n;

  // room_code 是房間的程式碼, 底下這一段是所有房間的共通點
  room_code = "// Room: " + tmp["file_name"] + @ROOM_CODE

inherit ROOM;

void create()
{
ROOM_CODE;
  // 一直到這邊結束

  room_code =
    sprintf ("%s  set (\"short\", \"%s\");\n"
               "  set (\"long\", @LONG\n%sLONG);\n\n",
             room_code, tmp["short"], tmp["long"]);

  name = keys(tmp);
  for(i=0; i<sizeof(name); i++) {
    if( member_array(name[i], special_props)!=-1 ) continue;
      if ( (intp(tmp[name[i]]) && tmp[name[i]]>0) ||
        (stringp(tmp[name[i]]) && tmp[name[i]] != "") ||
                (mapp(tmp[name[i]]) && tmp[name[i]] == ([])) ||
                sizeof (tmp[name[i]]) > 0)
                    room_code += sprintf("  set(\"%s\", %O);\n",
                                   name[i], tmp[name[i]] );
  }

  room_code += "  setup();\n  replace_program(ROOM);\n}\n";

  // Replace current directory with __DIR__ macro to make relocatable code.
  file = tmp["file_name"];
  i = strlen(file)-1;
  if (!file[i] == 'c' || !file[i-1] == '.') file += ".c";
  while( (i > 0) && (file[i]!='/')) i--;
  if( i>0 ) {
    write("目前目錄﹕" + file[0..i] + " 以 __DIR__ 取代。\n");
    room_code = replace_string(room_code, "\"" + file[0..i], "__DIR__\"");
  }

  if( file_size(file)!=-1 ) {
    write("檔案 " + file + " 已存在﹐要刪除舊檔嗎﹖[y/n]");
    input_to("save_room_file", file, room_code);
    return 1;
  }

  return save_room_file("y", file, room_code);
}

int do_saveroom(string arg)
{
        object env;
        string str, *name, file, pre, suc;
        mapping prop;
        int i;
        string cwd;

        env = environment(this_player());
        file = file_name(env) + ".c";

        if (file_size(file) <= 0) return
          notify_fail ("沒有這房間的檔案: "+file+"\n");

        name = explode (read_file (file), "\n");
        pre = "";
        for (i=0; i<sizeof (name); i++)
          if (strsrch (name[i], "void create") != 0)
            pre += name[i] + "\n";
          else break;
        pre += "void create ()\n{\n";

        i += 2;
        while (name && name[i][0..0] != "}") i++;
        suc = ""; i++;
        while (i<sizeof(name)) suc += name[i++]+"\n";

        prop = env->query_entire_dbase();

        str = pre;
        str = sprintf ("%s  set (\"short\", \"%s\");\n"
               "  set (\"long\", @LONG\n%sLONG);\n\n",
             str, prop["short"], prop["long"]);

        name = keys(prop);
        for(i=0; i<sizeof(name); i++) {
          if( member_array(name[i], special_props)!=-1 ) continue;
          if ( (intp(prop[name[i]]) && prop[name[i]]>0) ||
                (stringp(prop[name[i]]) && prop[name[i]] != "" ) ||
                (mapp(prop[name[i]]) && prop[name[i]] == ([])) ||
                sizeof (prop[name[i]]) > 0)
                    str += sprintf("  set(\"%s\", %O);\n",
                                   name[i], prop[name[i]] );
        }
        if (sizeof (suc) < 5)
         str += "\n  setup();\n  replace_program(ROOM);\n}\n";
        else
         str += "\n  setup();\n  replace_program(ROOM);\n}\n"+suc;


        // Replace current directory with __DIR__ macro to make relocatable code
        file = file_name(env);
        i = strlen(file)-1;
        while( (i > 0) && (file[i]!='/')) i--;
        if( i>0 ) {
          write("目前目錄﹕" + file[0..i] + " 以 __DIR__ 取代。\n");
          str = replace_string(str, "\"" + file[0..i], "__DIR__\"");
        }

        if( file_size(file)!=-1 ) {
                write("檔案 " + file + " 已存在﹐要刪除舊檔嗎﹖[y/n]");
                input_to("save_room_file", file, str);
                return 1;
        }

        return save_room_file("y", file, str);
}

int init_var ()
{
  tmp["no_fight"]               =       0;
  tmp["no_magic"]               =       0;
  tmp["no_clean_up"]            =       0;
  tmp["valid_startroom"]        =       0;
  tmp["file_name"]              =       "";
  tmp["short"]                  =       "";
  tmp["long"]                   =       "";
  tmp["outdoors"]               =       "";
  tmp["item_desc"]              =       ([]);
  tmp["exits"]                  =       ([]);
  tmp["objects"]                =       ([]);
}


int query_autoload() { return 1; }